# #+TITLE: Development logs, problems etc
* Problems
  Listed here is everything I havent managed to ponder upon or fix yet
  - *double, który jest intem*
  

* Links
  - [[https://stackoverflow.com/questions/8097620/how-to-read-from-input-until-newline-is-found-using-scanf][read until eol]]
  - [[https://stackoverflow.com/questions/5406935/reading-a-string-with-scanf/5407121][strings with scanf]]
  - [[https://stackoverflow.com/questions/1428911/detecting-eof-in-c][eof detection]]
  - [[https://en.wikipedia.org/wiki/Include_guard#File_"grandparent.h"][inclu guards]]
  - [[https://stackoverflow.com/questions/5607455/checking-that-malloc-succeeded-in-c][malloc failure]] -- *what to do then??* <-- /end with code 1/ -> ~exit(1)~
  - [[https://www.cplusplus.com/reference/cstdio/scanf/][scanf docs]]
  - [[https://unix.stackexchange.com/questions/239088/insert-result-of-command-into-an-executable-one-command][command res into an exec]]
  - [[https://man7.org/linux/man-pages/man3/getline.3.html][getline and getdelim]]
  - [[http://www.cplusplus.com/reference/cstdlib/strtoul/][stroul -- str to uns long]]
  - [[https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf][float flags scanf: %{f, g, G, a}]]
  - [[https://stackoverflow.com/questions/46195980/sscanfs-u-v-matching-signed-integers][scanf + signs]]
  - [[https://stackoverflow.com/questions/14802970/sscanf-with-hexadecimal-negative-value][negative hex vals]]
  - [[https://stackoverflow.com/questions/5796983/checking-if-float-is-an-integer][check if a float is an int]]
  - [[https://en.cppreference.com/w/c/numeric/math/ceil][ceil, ceilf, ceill docs]]
  - [[https://en.wikipedia.org/wiki/Scanf_format_string#Format_string_specifications][format str specifications]]
  - [[https://stackoverflow.com/a/840504][function ptr]]
  - [[https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/][casting voids + qsort]]
  - [[https://stackoverflow.com/a/27284318][qsort]]
  - [[https://stackoverflow.com/a/21097376][how does strtok work?]]
  - [[https://stackoverflow.com/q/5229343][inline across multi-file projet]]
  - [[https://github.com/python/cpython/blob/7591d9455eb37525c832da3d65e1a7b3e6dbf613/Objects/listobject.c#L61][nowa długość tablic]]


* Modules
  Keep it simple. Module ~m~ is ~m.c~ + ~m.h~. 

** module list
*** ~array~
*** ~input~
*** ~parse~
*** ~group~
*** ~main~

    
* Array
  One of the things I am most proud of.

  A small function to generate new length for an array:
  #+begin_src C
    size_t new_len(size_t curr_len)
    {
      return ((size_t)curr_len + (curr_len >> 3) + 6) & ~(size_t)3;
    }
  #+end_src
  An epic function that takes generic dynamic arrays, casts them at a general case

  Here is the dynamic array on which all other are based:
  #+begin_src C
    typedef struct dyn_anything {
      size_t used, len;
      void* val;
    } DynArr;
  #+end_src
  Here's the appending process:
  #+begin_src C
    void append(void* p, size_t width, void* new_el)
    {
      DynArr* a = (DynArr*)p;
      ++a->used;

      if (a->used >= a->len) {
        a->len = new_len(a->len);
        a->val = realloc(a->val, a->len * width);

        if (!a->val)
          exit(1);
      }

      memcpy((char*)a->val + ((a->used - 1) * width), new_el, width);
    }
  #+end_src
* Main
** the order of proceeding
   1. i create an initial array for parsed text in which I ll store all parsed lines. this i get from
      the ~parse~ module
   2. i call ~input~. it reads every line, calls ~parse~ on each of them and the parsed line gets added to
      the initial array for parsed text
      - I deal with the parsed line in a particular way
   3. having all lines safely parsed in the PText, I can proceed to sorting it
   4. this is done with ~group~
   5. having al of them sorted it is easy to find the identical ones

* Input

** how we do it now
   I use ~getline~ and keep this memory to allocate next lines.
   thus i have  ~readln~ and ~read_text~
   
   
** +old and dumb vers+
   All the input reading shall be done in the ~input~  module. I have two types decalared there
****   ~struct dyn_text~ vel *DText*
     A dynamic array storing lines of *DLine* type
**** ~struct dyn_line~ vel *DLine*
     Big strings allocated in a dynamic manner
     Expansion coeff -- ~input.h~ and the const ~EXPAND_ARR~

*** procedure
    1. ~read_text~ reads everything from ~stdin~
    2. ~read_line~ reads single lines

* Parse
  Parsing is in the ~parse~ module obviously. How should it be done?

  I take raw lines (ie. strings) and translate them into neat & tidy *PLines*
  a *PLine* should consist of
***** all the whole numbers
      for each I have a structure ~Whole~ which stores the number's sign and absolute value
***** all the reals
***** all the nans
**** The order
***** parse whole
***** parse real
***** parse nan
** Parsing different things  
*** Word splitting
    I shoudl use ~strtok~ from C stdlib. It is a little bit /strange/ but as far as I understand it
    the process is something like:
    
    1. you call ~strtok~ with a +string+ ~char*~,
    2. you give it delims (in my case this shall be whitespace),
    3. it replaces the delims with ~\0~ and points you at the begg of another string. Then you can
       use std string procedures on it cause for C sth like ~_char*_ + \0~ is as close to a string
       as u get

    Bettr described [[https://stackoverflow.com/questions/21097253/how-does-the-strtok-function-in-c-work][here]]
**** It works actually!
*** Parsing those single words/strings
    I use the ~strto*~ family ie ~strtoull~ and ~strtod~. I check the ~errno~ for ~ERANGE~ errors +
    I see whether everything is parsed. If not, the parsing unit returns false.
    
* Group
  I have a function that finds similars, each is normalised etc. a lot of qsorting all aroun.


* Memory

** with pythonian reallocs
*** ~podobnawe_wiersze.in~
    
    #+begin_example
      ==1173== 
      ==1173== HEAP SUMMARY:
      ==1173==     in use at exit: 0 bytes in 0 blocks
      ==1173==   total heap usage: 247 allocs, 247 frees, 43,231 bytes allocated
      ==1173== 
      ==1173== All heap blocks were freed -- no leaks are possible
      ==1173== 
      ==1173== For counts of detected and suppressed errors, rerun with: -v
      ==1173== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example    
*** ~example.in~    
    #+begin_example
      ==2844== 
      ==2844== HEAP SUMMARY:
      ==2844==     in use at exit: 0 bytes in 0 blocks
      ==2844==   total heap usage: 47 allocs, 47 frees, 11,544 bytes allocated
      ==2844== 
      ==2844== All heap blocks were freed -- no leaks are possible
      ==2844== 
      ==2844== For counts of detected and suppressed errors, rerun with: -v
      ==2844== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example
    
** with dumb reallocs (times 2)
*** ~podobnawe_wiersze.in~    
    #+begin_example
      ==5870== 
      ==5870== HEAP SUMMARY:
      ==5870==     in use at exit: 0 bytes in 0 blocks
      ==5870==   total heap usage: 236 allocs, 236 frees, 35,647 bytes allocated
      ==5870== 
      ==5870== All heap blocks were freed -- no leaks are possible
      ==5870== 
      ==5870== For counts of detected and suppressed errors, rerun with: -v
      ==5870== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example    
*** ~example.in~
    #+begin_example
      ==6718== 
      ==6718== HEAP SUMMARY:
      ==6718==     in use at exit: 0 bytes in 0 blocks
      ==6718==   total heap usage: 47 allocs, 47 frees, 11,864 bytes allocated
      ==6718== 
      ==6718== All heap blocks were freed -- no leaks are possible
      ==6718== 
      ==6718== For counts of detected and suppressed errors, rerun with: -v
      ==6718== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example
