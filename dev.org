# #+TITLE: Development logs, problems etc
* Problems
  Listed here is everything I havent managed to ponder upon or fix yet
  

* Links
  - [[https://stackoverflow.com/questions/8097620/how-to-read-from-input-until-newline-is-found-using-scanf][read until eol]]
  - [[https://stackoverflow.com/questions/5406935/reading-a-string-with-scanf/5407121][strings with scanf]]
  - [[https://stackoverflow.com/questions/1428911/detecting-eof-in-c][eof detection]]
  - [[https://en.wikipedia.org/wiki/Include_guard#File_"grandparent.h"][inclu guards]]
  - [[https://stackoverflow.com/questions/5607455/checking-that-malloc-succeeded-in-c][malloc failure]] -- *what to do then??*
  - [[https://www.cplusplus.com/reference/cstdio/scanf/][scanf docs]]
  - [[https://unix.stackexchange.com/questions/239088/insert-result-of-command-into-an-executable-one-command][command res into an exec]]
  - [[https://man7.org/linux/man-pages/man3/getline.3.html][getline and getdelim]]
  - [[http://www.cplusplus.com/reference/cstdlib/strtoul/][stroul -- str to uns long]]
  - [[https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf][float flags scanf: %{f, g, G, a}]]
  - [[https://stackoverflow.com/questions/46195980/sscanfs-u-v-matching-signed-integers][scanf + signs]]
  - [[https://stackoverflow.com/questions/14802970/sscanf-with-hexadecimal-negative-value][negative hex vals]]
  - [[https://stackoverflow.com/questions/5796983/checking-if-float-is-an-integer][check if a float is an int]]
  - [[https://en.cppreference.com/w/c/numeric/math/ceil][ceil, ceilf, ceill docs]]
  - [[https://en.wikipedia.org/wiki/Scanf_format_string#Format_string_specifications][format str specifications]]
  - [[https://stackoverflow.com/a/840504][function ptr]]
  - [[https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/][casting voids + qsort]]
  - [[https://stackoverflow.com/a/27284318][qsort]]
  - [[https://stackoverflow.com/a/21097376][how does strtok work?]]


* Modules
  Keep it simple. Module ~m~ is ~m.c~ + ~m.h~. 

** module list
*** ~group~
*** ~input~
*** ~parse~
*** ~main~

    
* Main
  *everything returns an int* -- so that  each memory problem is documented by the integer exit code
   so i can end everything if such problem occurs
**   the order of proceeding
   1. i create an initial array for parsed text in which I ll store all parsed lines. this i get from
      the ~parse~ module
   2. i call ~input~. it reads every line, calls ~parse~ on each of them and the parsed line gets added to
      the initial array for parsed text
      - I deal with the parsed line in a particular way
   3. having all lines safely parsed in the PText, I can proceed to sorting it
      - custom comparator
   4. having al of them sorted it is easy to find the identical ones

* Input

** how we do it now
   In the input module (perhaps i shoudl change the name) I read data from stdin but then I dont
   save each line (which involves a lot of copying etc) but rather I have one dynamic line of
   ~DLine~ type which serves me as the main buffer for each line.

   when called it gets a *ptext* array to store the parsed text in

   After having loaded a single line it calls *parse* module's ~parse~ procedure to parse the read
   line which then gets added to the ptext

   
   
** +old vers+
   All the input reading shall be done in the ~input~  module. I have two types decalared there
****   ~struct dyn_text~ vel *DText*
     A dynamic array storing lines of *DLine* type
**** ~struct dyn_line~ vel *DLine*
     Big strings allocated in a dynamic manner
     Expansion coeff -- ~input.h~ and the const ~EXPAND_ARR~

*** procedure
    1. ~read_text~ reads everything from ~stdin~
    2. ~read_line~ reads single lines


* Parse
  Parsing is in the ~parse~ module obviously. How should it be done?

  I take raw *DLines* and translate them into neat & tidy *PLines*
  a *PLine* should consist of
***** all the ints
***** all the floats
***** all the nans
*** The order
** Parsing different things  
*** Word splitting
    I shoudl use ~strtok~ from C stdlib. It is a little bit /strange/ but as far as I understand it
    the process is something like:
    
    1. you call ~strtok~ with a +string+ ~char*~,
    2. you give it delims (in my case this shall be whitespace),
    3. it replaces the delims with ~\0~ and points you at the begg of another string. Then you can
       use std string procedures on it cause for C sth like ~_char*_ + \0~ is as close to a string
       as u get

    Bettr described [[https://stackoverflow.com/questions/21097253/how-does-the-strtok-function-in-c-work][here]]
*** Parsing those single words/strings
    I have come up with two approaches 
**** ~try_type~
     I define ~try_float~, ~try_int~ etc, then they call ~try_fromat_type~ with different format
     strings each for different kind of ~type~ of theirs. So

     ~try_int~ would get the *PLine* to edit, string to parse
     It would do sth like
     #+begin_src C
       if (try_format_int("%x", ...) || try_format_int("%o", ...) || ...)
           return 1;
       else
         return 0;
     #+end_src
     so try to parse it with different format strings.

     Each ~try_format~ would consist of a ~sscanf~ and (if succesfull) it'd append it to *PLine*
     ~type~ drawer.
**** ~try_polymorphic~
     Messing with polymorphism in C...

     So there'd be single ~try_poly~ func that would get four things:

     1. *PLine*
     2. string to parse
     3. format
     4. function that'd add the result to *PLine*

     It would try to scanf it with the appriopriate format and then save the result under any type
     basically but try to send it back and save inside *PLine* with the ~add~ function

     The ~add~ would be sth like

     =void(*add)(PLine, void *)=
     Why? Welllllll so as i can get /any type/ in ~poly_try~ I cannot send anything specific to the
     add func but a pointer to the result of scanf. So it would need to be ~void*~. But then I can
     cast it as I see fit.

     eg
     #+begin_src C
       void add_int(PLine pl, void* val)
       {
         int real_val = *(int*)val;
         /* add it somehau */
         add_int(pl.ints, real_val);
       }
     #+end_src
     Ofc i can keep add as one func that manages all of that
***** Would it werkk?
      Can I save result from ~sscanf(s, any_format, &some_long_long_var)~ under really any long long
      variable and only then /type it back/ in the ~add~ func?
***** Parse polymorphicallly a string...
      idk if that'd hold up since a *string is scanffed differentely than anything else*
      + strings have unnknown size. well perhaps the way is to scan it char wise.
      + so i can have multiple chars in there
      + with a separator of my choosing
      + hence that'd be the beg of a ~sig~

***** ok, this is not the best idea. *heres why*
      so i have to keep both each number and each *nan* separately. why? only then i can be sure
      whether a line is or isnt simmilar.

      hence the scanf-ing is not so straightforward.
      
***** code
      #+begin_src C
        /* POLYMORPHIC VARIANT */

        int try_polymorphic(PLine* pline, const char* s, const char* format,
                            void(*add)(PLine*, void*))
        {
          char val[256];

          if (sscanf(s, format, &val)) {
            add(pline, &val);
            return 1;
          } else
            return 0;
        }

        void add_parsed_int(PLine* pline, void * val)
        {
          long long num = *(long long *)val;
          pline->ints.used++;
          if (pline->ints.used >= pline->ints.len) {
            pline->ints.val = (long long *)realloc(pline->ints.val,pline->ints.len * sizeof(long long));
    
            if (!pline->ints.val)
              fprintf(stderr, "REALLOC FAILURE");
          }
          pline->ints.val[pline->ints.used - 1] = num;
        }

        void add_parsed_float(PLine* pline, void * val)
        {
          double num = *(double *)val;
          pline->floats.used++;
          if (pline->floats.used >= pline->floats.len) {
            pline->floats.val = (double *)realloc(pline->floats.val,pline->floats.len * sizeof(double));
    
            if (!pline->floats.val)
              fprintf(stderr, "REALLOC FAILURE");
          }
          pline->floats.val[pline->floats.used - 1] = num;
        }

        void add_parsed_string(PLine* pline, void * val)
        {
          char* str = *(char** )val;
          pline->nans.used++;
          /* etc */
        }

        int try_parse(PLine* pline, const char* s)
        {
          if (try_polymorphic(pline, s, "%i", add_parsed_int) ||
              try_polymorphic(pline, s, "%f", add_parsed_float) ||
              try_polymorphic(pline, s, "%g", add_parsed_float) ||
              try_polymorphic(pline, s, "%G", add_parsed_float) ||
              try_polymorphic(pline, s, "%s", add_parsed_string) ||)

        }
      #+end_src


* Group

* Form sigs/sort
  I'll have (for each pline) arrays of ints, floats and strings. So then I can either pump
  everything into the ~sig~ string or I can qsort all the plines with a comparator of sorts.

  Lets have all the arrays stored inside sorted beforehand.
  
** cus cmp
   How to compare them?
   ~pl1~ and ~pl2~. if ~pl1.ints.length > ~pl2.ints.length~ then ~pl1 > pl2~.
   If lengths eq, then check each idx. When there's a diff, then return the bigger as bigger

   same with strings but strcmp there. ugghhhhhhhhhh a lot of /rze≈∫ba/ all around here. me not likey

   tiresome
