# #+TITLE: Development logs, problems etc
* Problems
  Listed here is everything I havent managed to ponder upon or fix yet
  - *double, który jest intem*
  

* Links
  - [[https://stackoverflow.com/questions/8097620/how-to-read-from-input-until-newline-is-found-using-scanf][read until eol]]
  - [[https://stackoverflow.com/questions/5406935/reading-a-string-with-scanf/5407121][strings with scanf]]
  - [[https://stackoverflow.com/questions/1428911/detecting-eof-in-c][eof detection]]
  - [[https://en.wikipedia.org/wiki/Include_guard#File_"grandparent.h"][inclu guards]]
  - [[https://stackoverflow.com/questions/5607455/checking-that-malloc-succeeded-in-c][malloc failure]] -- *what to do then??* <-- /end with code 1/ -> ~exit(1)~
  - [[https://www.cplusplus.com/reference/cstdio/scanf/][scanf docs]]
  - [[https://unix.stackexchange.com/questions/239088/insert-result-of-command-into-an-executable-one-command][command res into an exec]]
  - [[https://man7.org/linux/man-pages/man3/getline.3.html][getline and getdelim]]
  - [[http://www.cplusplus.com/reference/cstdlib/strtoul/][stroul -- str to uns long]]
  - [[https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf][float flags scanf: %{f, g, G, a}]]
  - [[https://stackoverflow.com/questions/46195980/sscanfs-u-v-matching-signed-integers][scanf + signs]]
  - [[https://stackoverflow.com/questions/14802970/sscanf-with-hexadecimal-negative-value][negative hex vals]]
  - [[https://stackoverflow.com/questions/5796983/checking-if-float-is-an-integer][check if a float is an int]]
  - [[https://en.cppreference.com/w/c/numeric/math/ceil][ceil, ceilf, ceill docs]]
  - [[https://en.wikipedia.org/wiki/Scanf_format_string#Format_string_specifications][format str specifications]]
  - [[https://stackoverflow.com/a/840504][function ptr]]
  - [[https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/][casting voids + qsort]]
  - [[https://stackoverflow.com/a/27284318][qsort]]
  - [[https://stackoverflow.com/a/21097376][how does strtok work?]]
  - [[https://stackoverflow.com/q/5229343][inline across multi-file projet]]
  - [[https://github.com/python/cpython/blob/7591d9455eb37525c832da3d65e1a7b3e6dbf613/Objects/listobject.c#L61][nowa długość tablic]]


* Modules
  Keep it simple. Module ~m~ is ~m.c~ + ~m.h~. 

** module list
*** ~array~
*** ~input~
*** ~parse~
*** ~group~
*** ~main~

    
* Array
  One of the things I am most proud of.

  A small function to generate new length for an array:
  #+begin_src C
    size_t new_len(size_t curr_len)
    {
      return ((size_t)curr_len + (curr_len >> 3) + 6) & ~(size_t)3;
    }
  #+end_src
  An epic function that takes generic dynamic arrays, casts them at a general case

  Here is the dynamic array on which all other are based:
  #+begin_src C
    typedef struct dyn_anything {
      size_t used, len;
      void* val;
    } DynArr;
  #+end_src
  Here's the appending process:
  #+begin_src C
    void append(void* p, size_t width, void* new_el)
    {
      DynArr* a = (DynArr*)p;
      ++a->used;

      if (a->used >= a->len) {
        a->len = new_len(a->len);
        a->val = realloc(a->val, a->len * width);

        if (!a->val)
          exit(1);
      }

      memcpy((char*)a->val + ((a->used - 1) * width), new_el, width);
    }
  #+end_src
* Main
** the order of proceeding
   1. i create an initial array for parsed text in which I ll store all parsed lines. this i get from
      the ~parse~ module
   2. i call ~input~. it reads every line, calls ~parse~ on each of them and the parsed line gets added to
      the initial array for parsed text
      - I deal with the parsed line in a particular way
   3. having all lines safely parsed in the PText, I can proceed to sorting it
   4. this is done with ~group~
   5. having al of them sorted it is easy to find the identical ones

* Input

** how we do it now
   I use ~getline~ and keep this memory to allocate next lines.
   Single func: ~readln~
   
   
** +old vers+
   All the input reading shall be done in the ~input~  module. I have two types decalared there
****   ~struct dyn_text~ vel *DText*
     A dynamic array storing lines of *DLine* type
**** ~struct dyn_line~ vel *DLine*
     Big strings allocated in a dynamic manner
     Expansion coeff -- ~input.h~ and the const ~EXPAND_ARR~

*** procedure
    1. ~read_text~ reads everything from ~stdin~
    2. ~read_line~ reads single lines


* Parse
  Parsing is in the ~parse~ module obviously. How should it be done?

  I take raw lines (ie. strings) and translate them into neat & tidy *PLines*
  a *PLine* should consist of
***** all the whole numbers
      for each I have a structure ~Whole~ which stores the number's sign and absolute value
***** all the reals
***** all the nans
*** The order
**** parse whole
**** parse real
**** parse nan
** Parsing different things  
*** Word splitting
    I shoudl use ~strtok~ from C stdlib. It is a little bit /strange/ but as far as I understand it
    the process is something like:
    
    1. you call ~strtok~ with a +string+ ~char*~,
    2. you give it delims (in my case this shall be whitespace),
    3. it replaces the delims with ~\0~ and points you at the begg of another string. Then you can
       use std string procedures on it cause for C sth like ~_char*_ + \0~ is as close to a string
       as u get

    Bettr described [[https://stackoverflow.com/questions/21097253/how-does-the-strtok-function-in-c-work][here]]
**** It works actually!
*** Parsing those single words/strings
    I use the ~strto*~ family ie ~strtoull~ and ~strtod~. I check the ~errno~ for ~ERANGE~ errors +
    I see whether everything is parsed. If not, the parsing unit returns false.
    
***** COMMENT code (old)
      #+begin_src C
        /* POLYMORPHIC VARIANT */

        int try_polymorphic(PLine* pline, const char* s, const char* format,
                            void(*add)(PLine*, void*))
        {
          char val[256];

          if (sscanf(s, format, &val)) {
            add(pline, &val);
            return 1;
          } else
            return 0;
        }

        void add_parsed_int(PLine* pline, void * val)
        {
          long long num = *(long long *)val;
          pline->ints.used++;
          if (pline->ints.used >= pline->ints.len) {
            pline->ints.val = (long long *)realloc(pline->ints.val,pline->ints.len * sizeof(long long));
    
            if (!pline->ints.val)
              fprintf(stderr, "REALLOC FAILURE");
          }
          pline->ints.val[pline->ints.used - 1] = num;
        }

        void add_parsed_float(PLine* pline, void * val)
        {
          double num = *(double *)val;
          pline->floats.used++;
          if (pline->floats.used >= pline->floats.len) {
            pline->floats.val = (double *)realloc(pline->floats.val,pline->floats.len * sizeof(double));
    
            if (!pline->floats.val)
              fprintf(stderr, "REALLOC FAILURE");
          }
          pline->floats.val[pline->floats.used - 1] = num;
        }

        void add_parsed_string(PLine* pline, void * val)
        {
          char* str = *(char** )val;
          pline->nans.used++;
          /* etc */
        }

        int try_parse(PLine* pline, const char* s)
        {
          if (try_polymorphic(pline, s, "%i", add_parsed_int) ||
              try_polymorphic(pline, s, "%f", add_parsed_float) ||
              try_polymorphic(pline, s, "%g", add_parsed_float) ||
              try_polymorphic(pline, s, "%G", add_parsed_float) ||
              try_polymorphic(pline, s, "%s", add_parsed_string) ||)

        }
      #+end_src


* Group
  I have a function that finds similars, each is normalised etc. a lot of qsorting all aroun.

