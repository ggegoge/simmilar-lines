# #+TITLE: Development logs, problems etc
* Problems
  Listed here is everything I havent managed to ponder upon or fix yet
  - *double, który jest intem*
  

  - [X] *double, który jest intem*
  - [X] 0x == 0
  - [ ] fully assuredd?

* Links
  - [[https://stackoverflow.com/questions/8097620/how-to-read-from-input-until-newline-is-found-using-scanf][read until eol]]
  - [[https://stackoverflow.com/questions/5406935/reading-a-string-with-scanf/5407121][strings with scanf]]
  - [[https://stackoverflow.com/questions/1428911/detecting-eof-in-c][eof detection]]
  - [[https://en.wikipedia.org/wiki/Include_guard#File_"grandparent.h"][inclu guards]]
  - [[https://stackoverflow.com/questions/5607455/checking-that-malloc-succeeded-in-c][malloc failure]] -- *what to do then??* <-- /end with code 1/ -> ~exit(1)~
  - [[https://www.cplusplus.com/reference/cstdio/scanf/][scanf docs]]
  - [[https://unix.stackexchange.com/questions/239088/insert-result-of-command-into-an-executable-one-command][command res into an exec]]
  - [[https://man7.org/linux/man-pages/man3/getline.3.html][getline and getdelim]]
  - [[http://www.cplusplus.com/reference/cstdlib/strtoul/][stroul -- str to uns long]]
  - [[https://stackoverflow.com/questions/19894483/is-there-any-difference-in-using-f-e-g-e-or-g-with-scanf][float flags scanf: %{f, g, G, a}]]
  - [[https://stackoverflow.com/questions/46195980/sscanfs-u-v-matching-signed-integers][scanf + signs]]
  - [[https://stackoverflow.com/questions/14802970/sscanf-with-hexadecimal-negative-value][negative hex vals]]
  - [[https://stackoverflow.com/questions/5796983/checking-if-float-is-an-integer][check if a float is an int]]
  - [[https://en.cppreference.com/w/c/numeric/math/ceil][ceil, ceilf, ceill docs]]
  - [[https://en.wikipedia.org/wiki/Scanf_format_string#Format_string_specifications][format str specifications]]
  - [[https://stackoverflow.com/a/840504][function ptr]]
  - [[https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/][casting voids + qsort]]
  - [[https://stackoverflow.com/a/27284318][qsort]]
  - [[https://stackoverflow.com/a/21097376][how does strtok work?]]
  - [[https://stackoverflow.com/q/5229343][inline across multi-file projet]]
  - [[https://github.com/python/cpython/blob/7591d9455eb37525c832da3d65e1a7b3e6dbf613/Objects/listobject.c#L61][nowa długość tablic]]
  - [[https://stackoverflow.com/a/19246806][script detecting valgrind errors]]


* Modules
  Keep it simple. Module ~m~ is ~m.c~ { + ~m.h~ } 

** module list
*** ~array~
*** ~input~
*** ~parse~
*** ~compare~
*** ~group~
*** ~main~

    
* Array
  One of the things I am most proud of.

  A small function to generate new length for an array:
  #+begin_src C
    size_t new_len(size_t curr_len)
    {
      return ((size_t)curr_len + (curr_len >> 3) + 6) & ~(size_t)3;
    }
  #+end_src
  It is based on the [[https://github.com/python/cpython/blob/96eeff516204b7cc751103fa33dcc665e387846e/Objects/listobject.c#L61][Python's list resize mechanism]] (or rather /copied from/ not based) but in the
  final version I suppose I'll use dumb reallocs ie. multiply the new length by 2. Perhaps I should
  make a constant ~ARRAY_RESIZE_COEFF~ or sth like that. See more in
  [[mem][section concerning memory usage]]
  
  Here is the dynamic array on which all other are based:
  #+begin_src C
    typedef struct DynArr {
      size_t used, len;
      void* val;
    } DynArr;
  #+end_src

  ~used~ tells you how many fields/cells of the array are filled with something. ~len~ is the actual
  length of allocated memory. Eg:
  
  | 1 | 2 | 3 | 4 | ? | ? | ? | ? | ? |

  would represent an array ~a~ with ~a.used = 4~ but ~a.len = 9~. This way it is resized only so
  often because of reallocation being necessary iff ~a.used >= a.len~.

  The pointer ~a.val~ points at the array itself. Here it is ~void*~ but because of that it can be
  *anything* really. We shall go back to that later.
  
  Here's the appending process:
  
  #+begin_src C
    void array_append(void* p, size_t width, void* new_el)
    {
      DynArr* a = (DynArr*)p;
      ++a->used;

      if (a->used >= a->len) {
        a->len = new_len(a->used);
        a->val = realloc(a->val, a->len * width);

        if (!a->val)
          exit(1);
      }

      memcpy((char*)a->val + ((a->used - 1) * width), new_el, width);
    }
  #+end_src

  Here is the initialisation
  
  #+begin_src C
    void array_init(void* p, size_t width, size_t len)
    {
      DynArr* a = (DynArr*)p;
      a->used = 0;
      a->len = len;

      if (a->len == 0) {
        a->val = NULL;
        return;
      }

      a->val = malloc(a->len * width);

      if (!a->val)
        exit(1);
    }
  #+end_src

  Here comes the *polymorphism*. We can declare an int array:
  
  #+begin_src C
    typedef struct IntArray {
      size_t use, len;
      int* val;
    } IntArray;
  #+end_src

  Then we can simply initialise it and use it with our commands
  
  #+begin_src C
    IntArray arr;

    array_initialise(&arr, sizeof(int), 0);

    for (int i = 1; i <= 4; ++i)
      array_append(&arr, sizeof(int), &i);
  #+end_src

  which would generate the table described with the table above
* Main
** the order of proceeding
   1. i create an initial array for parsed text in which I ll store all parsed lines. this i get from
      the ~parse~ module
   2. i call ~input~. it reads every line, calls ~parse~ on each of them and the parsed line gets added to
      the initial array for parsed text
      - I deal with the parsed line in a particular way
   3. having all lines safely parsed in the ParsedText, I can proceed to sorting it
   4. this is done with ~group~
   5. having al of them sorted it is easy to find the identical ones

* Input

** how we do it now
   I use ~getline~ and keep this memory to allocate next lines.
   thus i have  ~read_line~ and ~read_text~
   
   
** +old and dumb vers which was replaced with getline+
   All the input reading shall be done in the ~input~  module. I have two types decalared there
****   ~struct dyn_text~ vel *DText*
     A dynamic array storing lines of *DLine* type
**** ~struct dyn_line~ vel *DLine*
     Big strings allocated in a dynamic manner
     Expansion coeff -- ~input.h~ and the const ~EXPAND_ARR~

*** procedure
    1. ~read_text~ reads everything from ~stdin~
    2. ~read_line~ reads single lines

* Parse
  Parsing is in the ~parse~ module obviously. How should it be done?

  I take raw lines (ie. strings) and translate them into neat & tidy *ParsedLines*
  a *ParsedLine* should consist of
***** all the whole numbers
      for each I have a structure ~Whole~ which stores the number's sign and absolute value
***** all the reals
***** all the nans
**** The order
***** parse whole
***** parse real
***** parse nan
** Parsing different things  
*** Word splitting
    I shoudl use ~strtok~ from C stdlib. It is a little bit /strange/ but as far as I understand it
    the process is something like:
    
    1. you call ~strtok~ with a +string+ ~char*~,
    2. you give it delims (in my case this shall be whitespace),
    3. it replaces the delims with ~\0~ and points you at the begg of another string. Then you can
       use std string procedures on it cause for C sth like ~_char*_ + \0~ is as close to a string
       as u get

    Bettr described [[https://stackoverflow.com/questions/21097253/how-does-the-strtok-function-in-c-work][here]]
**** It works actually!
*** Parsing those single words/strings
    I use the ~strto*~ family ie ~strtoull~ and ~strtod~. I check the ~errno~ for ~ERANGE~ errors +
    I see whether everything is parsed. If not, the parsing unit returns false.
    
* Group
  I have a function that finds similars, each is normalised etc. a lot of qsorting all aroun.

* Compare
  a ~group~ dependency -- necessary because of the qsorting which needs some order for comparisons
  etc 

* Memory <<mem>>

** with pythonian reallocs
*** ~podobnawe_wiersze.in~
    
    #+begin_example
      ==1173== 
      ==1173== HEAP SUMMARY:
      ==1173==     in use at exit: 0 bytes in 0 blocks
      ==1173==   total heap usage: 247 allocs, 247 frees, 43,231 bytes allocated
      ==1173== 
      ==1173== All heap blocks were freed -- no leaks are possible
      ==1173== 
      ==1173== For counts of detected and suppressed errors, rerun with: -v
      ==1173== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example    
*** ~example.in~    
    #+begin_example
      ==2844== 
      ==2844== HEAP SUMMARY:
      ==2844==     in use at exit: 0 bytes in 0 blocks
      ==2844==   total heap usage: 47 allocs, 47 frees, 11,544 bytes allocated
      ==2844== 
      ==2844== All heap blocks were freed -- no leaks are possible
      ==2844== 
      ==2844== For counts of detected and suppressed errors, rerun with: -v
      ==2844== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example
    
** with dumb reallocs (times 2)
*** ~podobnawe_wiersze.in~    
    #+begin_example
      ==5870== 
      ==5870== HEAP SUMMARY:
      ==5870==     in use at exit: 0 bytes in 0 blocks
      ==5870==   total heap usage: 236 allocs, 236 frees, 35,647 bytes allocated
      ==5870== 
      ==5870== All heap blocks were freed -- no leaks are possible
      ==5870== 
      ==5870== For counts of detected and suppressed errors, rerun with: -v
      ==5870== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example    
*** ~example.in~
    #+begin_example
      ==6718== 
      ==6718== HEAP SUMMARY:
      ==6718==     in use at exit: 0 bytes in 0 blocks
      ==6718==   total heap usage: 47 allocs, 47 frees, 11,864 bytes allocated
      ==6718== 
      ==6718== All heap blocks were freed -- no leaks are possible
      ==6718== 
      ==6718== For counts of detected and suppressed errors, rerun with: -v
      ==6718== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
    #+end_example
