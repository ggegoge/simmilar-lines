
* Pytania poleceniowe
** Styl kodu
*** Czy można używać ~std=c89~ bądź ~c99~? Lub ~c17~?
*** styl klamer -- jak je łamać?
**** przykładowe style

     allman
     #+begin_src C
       int Foo(bool isBar)
       {
           if (isBar)
           {
               bar();
               return 1;
           }
           else
               return 0;
       }
     #+end_src

     k&r -- *preferowany mój*
     #+begin_src C
       int Foo(bool isBar)
       {
           if (isBar) {
               bar();
               return 1;
           } else
               return 0;
       }
     #+end_src

     gnu
     #+begin_src C
       int Foo(bool isBar)
       {
           if (isBar)
               {
                   bar();
                   return 1;
               }
           else
               return 0;
       }
     #+end_src

     kernel normal form
     #+begin_src C
       int Foo(bool isBar)
       {
               if (isFoo) {
                       bar();
                       return 1;
               } else
                       return 0;
       }
     #+end_src

     google
     #+begin_src C
       int Foo(bool isBar) {
           if (isBar) {
               bar();
               return 1;
           } else
               return 0;
       }
     #+end_src
*** typ z dwoma gwiazdkami
**** ~node**~ czy ~Tree*~?
*** nazwy typów dużą?
** Wczytywanie danych
*** Czy dane mają być wczytane od razu w całości?
**** tj czy mamy na bieżąco aktualizować zasób słów i grup czy np najpierw wczytać wszystko?
***** wolałbym najpierw wsjo
** komentarze
*** czy zawsze na początku?
    linijki
    #+begin_example
      |1|# 3444
      |2| # 3444
      |3| 34#44
    #+end_example
    czy wszystkie te są ok? numerki to nr-y linii
*** odp: *tak*
** czy int może być równy floatowi? np ~3.0 = 3~?
** czy nazwy plików 1-1? Tak jest napisane, ale np ~Makefile~ zamiast ~makefile~?
* Kwestie implementacyjne
** Jaki pomysł na razie ogólnie?
   Myślę o czymś /dość prostym/. Porgram wykonuje następujące etapy:
   1. wczytanie wszystkich wierszy
      - z pominięciem komentarzy?
      - zapisuję wiersz + jego oryginalny numer?
   2. transformacja każdego w obiekty wierszowe
      1. podział na słowa (kolejne rzeczy oddzielone white space'em)
      2. wczytanie odpowiednie każdego słowa -- wiedzieć trzeba czy to =float= czy =int= (a raczej
         de facto =long=) czy string
      3. normalizacja słów
   3. tablica z każdym stransformowanym wierszem -- sortujemy ją po identyczności.
      1. albo tworzymy custom comparator jakoś
      2. albo tworzymy wierszom /sygnatury/ tj stringi specjalne i sortujemy za pomocą =strcmp=
         1. funkcja ~sig : wiersz -> string~ miałaby być *różnowartościowa*.
         2. Zawiera wszystkie inty, floaty i stringi w sobie w /postaci normalnej/
         3. kolejność odpowiednia, oddzielone delimiterem np ~_~?
         4. więc =abcd 2137 123 9.3= przeszłoby w ~123_2137_9.1_abcd~ itd
   4. z posortowanej łatwo już wydedukować powtórzenia -- zbieramy je po kolei. Stable sort jakiś by
      się miało to by zachowało numery wierszy -- wtedy by w danej grupie pierwszy był ten o najmn
      wierszu chyba [[https://stackoverflow.com/a/6105590][so1]], [[https://www.gnu.org/software/libc/manual/html_node/Array-Sort-Function.html][gnu]], z pointerami [[https://nullprogram.com/blog/2014/08/29/][o tu]]
   5. sortujemy ponownie po najmnn nrz-e wiersza i mamy gotowe ugrupowanie

** Podział na moduły
*** wczytanie do pamięci pliku
**** uwaga na komentarze i puste linie
*** parse'owanie wierszy
**** rozbicie wiersza na słowa
**** normalizacja słów
**** tworzenie sygnatur/obiektów wierszowych
*** sort
*** łapanie grup
*** wyjście
*** *main*
** problemy
*** implementacja w pamięci: structy itp
**** różne typy [[https://stackoverflow.com/a/34833131][opisane tutaj]]
*** funkcja biorąca jako parametr funkcję
**** chciałbym takie coś bo wygląda bardzo fajnie, ale gdzie mogę tego użyć aby to miało sens?
***** może... może jakoś w parse'owaniu? daję każdemu słowu jego parser/złożenie parserów?
****** najpierw klasyfikuję wszystkich, a potem mam osobne funkcje dla każdego typu i je po kolei daję
******* tym samym uzyskałbym tenże efekt jakoś. ale może da się lepiej?
******** wow, można bardzo głęboko wciąć się w orgu
*** wczytywanie
**** =getline=? =scanf=?
**** komentarze ogarniać jakoś
**** whitespace dziwny
**** podział na słowa linijek
**** dynamicznie pamięciować
*** parse'owanie
**** błędy łapać
**** podział na osobne słowa
     np "hejże  ino 333  444      123" --> "hejże" "ino" "333" "444" "123"
     lub po prostu wiedzieć gdzie oni są
     funkcja =strtok= chyba to robi... [[http://www.cplusplus.com/reference/cstring/strtok/][tutaj opis]] o c++ ale jest chyba w C
     
     /The point where the last token was found is kept internally by the function to be used on the
     next call (particular library implementations are not required to avoid data races)./
     ~ =strtok=
     wtf
**** =sscanf= -- tym i odpowiednimi =%coś= mogę wczytywać heksy itp
**** =sprintf= tym mogę zapisywać postać po normalizacji
**** sprawdzian
     Można sprawdzić czy np string ~s~ jest parse'owalny jako liczba ósemkowa poprzez dość prosty
     test typu:
     #+begin_src C
       if (sscanf("%o", s) == 1) {
         /* jest oktal */
       }
       else
         /* nie jest */
     #+end_src
     Zatem odpowiednie złożenie kolejności scanfów może być ok.
***** Jakie chary występują?
      /ciągu znaków o kodach ASCII od 33 do 126./
      Czyli
****** tabelka wielka
       |  33 | ! |
       |  34 | " |
       |  35 | # |
       |  36 | $ |
       |  37 | % |
       |  38 | & |
       |  39 | ' |
       |  40 | ( |
       |  41 | ) |
       |  42 | * |
       |  43 | + |
       |  44 | , |
       |  45 | - |
       |  46 | . |
       |  47 | / |
       |  48 | 0 |
       |  49 | 1 |
       |  50 | 2 |
       |  51 | 3 |
       |  52 | 4 |
       |  53 | 5 |
       |  54 | 6 |
       |  55 | 7 |
       |  56 | 8 |
       |  57 | 9 |
       |  58 | : |
       |  59 | ; |
       |  60 | < |
       |  61 | = |
       |  62 | > |
       |  63 | ? |
       |  64 | @ |
       |  65 | A |
       |  66 | B |
       |  67 | C |
       |  68 | D |
       |  69 | E |
       |  70 | F |
       |  71 | G |
       |  72 | H |
       |  73 | I |
       |  74 | J |
       |  75 | K |
       |  76 | L |
       |  77 | M |
       |  78 | N |
       |  79 | O |
       |  80 | P |
       |  81 | Q |
       |  82 | R |
       |  83 | S |
       |  84 | T |
       |  85 | U |
       |  86 | V |
       |  87 | W |
       |  88 | X |
       |  89 | Y |
       |  90 | Z |
       |  91 | [ |
       |  92 | \ |
       |  93 | ] |
       |  94 | ^ |
       |  95 | _ |
       |  96 | ` |
       |  97 | a |
       |  98 | b |
       |  99 | c |
       | 100 | d |
       | 101 | e |
       | 102 | f |
       | 103 | g |
       | 104 | h |
       | 105 | i |
       | 106 | j |
       | 107 | k |
       | 108 | l |
       | 109 | m |
       | 110 | n |
       | 111 | o |
       | 112 | p |
       | 113 | q |
       | 114 | r |
       | 115 | s |
       | 116 | t |
       | 117 | u |
       | 118 | v |
       | 119 | w |
       | 120 | x |
       | 121 | y |
       | 122 | z |
       | 123 | { |
       | 124 |   |
       | 125 | } |
       | 126 | ~ |
****** + białe znaki
       ascii 32, 9, 10, 11, 12, 13 tj = =, =\t=, =\n=, =\v=, =\f=, =\r=.
***** kolejność parse'owania
      jakaś gramatika by sb przydała.
      #+begin_example
        <wiersz> ::= <pusty wiersz> | <komentarz> | { <liczba> | <nieliczba> }+
        <pusty wiersz> ::= <whitespace>+
        <komentarz> ::= '#' <*>

        <liczba> ::= <liczba szesnastkowa> | <liczba ósemkowa> | <liczba dziesiętna> | <float>
      #+end_example
      ech.
      
**** Jak wygląda postać normalna?
     Biorąc pod uwagę, że wielkość floata może wyjść poza zakres, to może najlepsze jest trzymanie
     liczb.. hm... Jako ="19000000000000000000.0"= lub =20e20=? Oczywiście jako long long by nie
     weszły. aha. ale nie porównam ich nigdy z intem, więc to nie jest problem. zatem nie ma co.

     Czyli w postaci normalnej inty jako inty. Floaty w postaci.. hm. Zmienno przeć? Chyba nie z
     ~e~. Zmienno przeć najpewniejsza.
*** sort -- [[https://pl.wikibooks.org/wiki/C/qsort][qsort]]
**** strcmp, stable? [[https://nullprogram.com/blog/2014/08/29/][stable sort tutorial]]
**** sortować później każdej grupy osobno numery? później całość posortować /encore une fois/ po min nr?
*** łapanie grup
